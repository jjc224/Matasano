# Challenge 31: implement and break HMAC-SHA1 with an artificial timing leak (client).

# The primary function is written procedurally for the sake of a pretty output considering the time it takes to complete the attack.
# The reason it takes so long to is due to the way HMAC signatures are (insecurely) compared on the server-side (byte-at-a-time with early-exit, which causes the timing leak).
# The time is therefore highly dependent on the artificial timing leak, as you have to wait for sleep().

require 'net/http'

# Performs a HTTP request to the server which verifies that a given filename corresponds with a given HMAC signature.
# Returns the body of the request as dictated by the server ('200 OK' or '500 Internal Server Error').
def do_request(file, signature)
  uri       = URI('http://localhost:4567/test')
  params    = {:file => file, :signature => signature}
  uri.query = URI.encode_www_form(params)
  result    = Net::HTTP.get_response(uri)

  result.body
end

# NOTE: Added this to 'matasano_lib/monkey_patch' as Array.median for the future.
def median(array)
  return nil if array.empty?

  sorted = array.sort
  mid    = array.size / 2

  if array.size.even?
    (sorted[mid - 1] + sorted[mid]).to_f / 2
  else
    sorted[mid]
  end
end

# Parameters:
#   request: A callback method which performs the HTTP request that verifies a filename against a HMAC signature against the server.
#   file:    The filename to attempt to find the HMAC signature for given the timing leak generated by the request's response.
#   rounds:  The number of times to loop through all possible bytes for each position in the HMAC signature - higher round => greater probability/accuracy at the expense of runtime.
def timing_attack(request: method(:do_request), file: 'foo', rounds:)
  label = 'Recovered HMAC:'
  print label

  payload     = ['00'] * 20  # 40 zero-nibbles - a HMAC-SHA1 signature modified for recovery.
  differences = Hash.new { |h, k| h[k] = [] }

  payload.size.times do |i|
    rounds.times do
      (0..255).each do |byte|
        time = Time.now
        request.call(file, payload.join)
        delta = Time.now - time

        hex_byte   = '%02x' % byte
        payload[i] = hex_byte
        differences[hex_byte] << delta
      end
    end

    byte        = differences.sort_by { |_, v| median(v) }.last[0]
    payload[i]  = '%02x' % (byte.hex - 1)
    differences = Hash.new { |h, k| h[k] = [] }

    print "\r#{label} #{payload[0..i].join}"
  end

  puts  # Newline.
end

# Six rounds appears to be the least yet optimal number for correlating any given filename with its signature given the server-side time leak.
# This has been tested thoroughly with a variety of filenames, some of which were extremely lengthy and "odd" in terms of the charset.
timing_attack(rounds: 6)  # NOTE: The number of rounds can be reduced on a case-by-case basis (depending on the complexity of the filename).

# Output:
# -----------------------------------------------------------------------------
# [josh@purehacking] [/dev/ttys003] [~/Projects/Matasano/Ruby]> time ruby 31.rb
# Recovered HMAC: 274b7c4d98605fcf739a0bf9237551623f415fb8
# ruby 31.rb  37.58s user 15.62s system 0% cpu 4:26:16.94 total
