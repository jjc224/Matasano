# Challenge 32: break HMAC-SHA1 with a slightly less artificial timing leak (client).

# The primary function is written procedurally for the sake of a pretty output considering the time it takes to complete the attack.
# The reason it takes so long to is due to the way in which HMAC signatures are (insecurely) compared on the server-side (byte-at-a-time with early-exit, which causes the timing leak).

require 'net/http'
require_relative 'matasano_lib/monkey_patch'

# Performs a HTTP request to the server which verifies that a given filename corresponds with a given HMAC signature.
# Returns the body of the request as dictated by the server ('200 OK' or '500 Internal Server Error').
def do_request(file, signature)
  uri       = URI('http://localhost:4567/test')
  params    = {:file => file, :signature => signature}
  uri.query = URI.encode_www_form(params)
  result    = Net::HTTP.get_response(uri)

  result.body
end

def median(array)
  size   = array.size
  sorted = array.sort

  size.even? ? sorted[size / 2] : (sorted[size / 2 - 1] + sorted[size / 2]).to_f / 2
end

# Parameters:
#   request: A callback method which performs the HTTP request that verifies a filename against a HMAC signature against the server.
#   file:    The filename to attempt to find the HMAC signature for given the timing leak generated by the request's response.
#   rounds:  The number of times to loop through all possible bytes for each position in the HMAC signature - higher round => greater probability/accuracy at the expense of runtime.
def timing_attack(request: method(:do_request), file: 'foo', rounds:)
  label = 'Recovered HMAC:'
  print label

  payload     = ['00'] * 20  # 40 zero-nibbles - a HMAC-SHA1 signature modified for recovery.
  differences = Hash.new { |h, k| h[k] = [] }

  payload.size.times do |i|
    rounds.times do
      (0..255).each do |byte|
        time = Time.now
        request.call(file, payload.join)
        delta = Time.now - time

        hex_byte   = '%02x' % byte
        payload[i] = hex_byte
        differences[hex_byte] << delta
      end
    end

    byte        = differences.sort_by { |_, v| median(v) }.last[0]
    payload[i]  = '%02x' % (byte.hex - 1)
    differences = Hash.new { |h, k| h[k] = [] }

    print "\r#{label} #{payload[0..i].join}"
  end

  puts  # Newline.
end

# 15 rounds appears to be the least yet optimal number for correlating any given filename with its signature given the server-side time leak.
# This has been tested thoroughly with a variety of filenames, some of which were extremely lengthy and "odd" in terms of the charset.
timing_attack(rounds: 15)  # NOTE: The number of rounds can be reduced on a case-by-case basis (depending on the complexity of the filename).

# Output:
# -----------------------------------------------------------------------------
# [josh@purehacking] [/dev/ttys002] [~/Projects/Matasano/Ruby]> time ruby 32.rb
# Recovered HMAC: 274b7c4d98605fcf739a0bf9237551623f415fb8
# ruby 32.rb  87.88s user 35.03s system 2% cpu 1:18:20.82 total
