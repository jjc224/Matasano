# Challenge 32: break HMAC-SHA1 with a slightly less artificial timing leak (client).

# The primary function is written procedurally for the sake of a pretty output considering the time it takes to complete the attack.
# The reason it takes so long to is due to the way HMAC signatures are (insecurely) compared on the server-side (byte-at-a-time with early-exit, which causes the timing leak).
# The time is therefore highly dependent on the artificial timing leak, as you have to wait for sleep().

# Solution is identical to 31 since I already made the efficient solution the first time (using median).
# The naive solution for 31 was probably to just choose the highest delta (not use any descriptive statistics).

# This challenge asks to test a 5ms delay down until it breaks. Still working at 0.1ms (see 32_server.rb).
# You likely can use even smaller delays if you just increase the rounds for timing_attack().

require 'net/http'

# Performs a HTTP request to the server which verifies that a given filename corresponds with a given HMAC signature.
# Returns the body of the request as dictated by the server ('200 OK' or '500 Internal Server Error').
def do_request(file, signature)
  uri       = URI('http://localhost:4567/test')
  params    = {:file => file, :signature => signature}
  uri.query = URI.encode_www_form(params)
  result    = Net::HTTP.get_response(uri)

  result.body
end

# NOTE: Added this to 'matasano_lib/monkey_patch' as Array.median for the future.
def median(array)
  return nil if array.empty?

  sorted = array.sort
  mid    = array.size / 2

  if array.size.even?
    (sorted[mid - 1] + sorted[mid]).to_f / 2
  else
    sorted[mid]
  end
end

# Parameters:
#   request: A callback method which performs the HTTP request that verifies a filename against a HMAC signature against the server.
#   file:    The filename to attempt to find the HMAC signature for given the timing leak generated by the request's response.
#   rounds:  The number of times to loop through all possible bytes for each position in the HMAC signature - higher round => greater probability/accuracy at the expense of runtime.
def timing_attack(request: method(:do_request), file: 'foo', rounds:)
  label = 'Recovered HMAC:'
  print label

  payload     = ['00'] * 20  # 40 zero-nibbles - a HMAC-SHA1 signature modified for recovery.
  differences = Hash.new { |h, k| h[k] = [] }

  payload.size.times do |i|
    rounds.times do
      (0..255).each do |byte|
        time = Time.now
        request.call(file, payload.join)
        delta = Time.now - time

        hex_byte   = '%02x' % byte
        payload[i] = hex_byte
        differences[hex_byte] << delta
      end
    end

    byte        = differences.sort_by { |_, v| median(v) }.last[0]
    payload[i]  = '%02x' % (byte.hex - 1)
    differences = Hash.new { |h, k| h[k] = [] }

    print "\r#{label} #{payload[0..i].join}"
  end

  puts  # Newline.
end

# Only increased rounds from 15 to 20 and tested for default filename ('foo') since 15 rounds got the final byte or two wrong.
# This is because the previous challenge (#31) uses the same code, and the code has already been tested thoroughly. 
# The only change here (server side) is the timing leak has been decreased. The solution implemented as of #31 is already optimal per the use of median.
timing_attack(rounds: 20)  # NOTE: The number of rounds can be reduced on a case-by-case basis (depending on the complexity of the filename).

# Output:
# -----------------------------------------------------------------------------
# [josh@purehacking] [/dev/ttys002] [~/Projects/Matasano/Ruby]> time ruby 32.rb
# Recovered HMAC: 274b7c4d98605fcf739a0bf9237551623f415fb8
# ruby 32.rb  21.80s user 10.78s system 8% cpu 6:05.66 total
